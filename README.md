<details>
<summary><b>Домашнее задание к занятию «Введение в Java»</b></summary>

## Задание 1 (обязательное)

Ваша задача — проанализировать программу расчёта распределения ингредиентов на порцию. Программе на вход даётся рецепт с количеством каждого ингредиента, а также количество человек, которые будут в одинаковых порциях его есть. На выходе программа указывает без округлений, какое точное количество каждого ингредиента пришлось на одну порцию еды.

```java
public class Main {
    public static void main(String[] args) {

        int eaters = 5; // сколько людей будут есть

        int water = 3000; // миллилитров воды
        int potatoes = 5; // картофелин
        int chicken = 6; // куриных бёдер
        int spices = 10; // ложек специй

        System.out.println("Сварили суп. На одного человека вышло:");
        System.out.println((water / eaters) + " миллилитров(а) воды");
        System.out.println((potatoes / eaters) + " картофелин(а/ы)");
        System.out.println((chicken / eaters) + " куриных(ое) бёдер(ро)");
        System.out.println((spices / eaters) + " ложек(ки/ка) специй");

    }
}
```

Для анализа этой программы

1. Создайте новый проект на основе **Java 11**.
2. Создайте класс `Main` с содержимым из кода выше.
3. Нажмите на кнопку запуска программы. Она должна запуститься, вывести информацию на экран и завершиться.
4. Закоммитьте и запушьте ваш проект в публичный репозиторий на GitHub. Не забудьте правильно его настроить в плане игнорирования ненужных файлов.
5. Проанализируйте код и вывод программы. Найдите в ней дефект. Менять как-либо код программы нельзя.
6. Оформите баг-репорт с помощью GitHub Issues, описывающий найденный дефект по шаблону из примера ниже.
</details>

[Моё решение к занятию «Введение в Java»](https://github.com/Alexnoh87/Java)

<details>
<summary><b>Домашнее задание к занятию «Примитивные типы данных и условные операторы»</b></summary>

## Задание 1 — обязательное

В этой задаче мы считаем, что пользователь вводит корректные значения входных данных.

Авиаперевозчики предлагают различные бонусные программы, начисляющие бесплатные мили за перелёты.
Формула  расчёта следующая: за каждые 20 рублей, потраченные на билет, начисляется 1 миля. Дробные мили не начисляются.

Например, при стоимости билета в 13 676 рублей должно начислиться 683 бонусов.

Нужно создать приложение, рассчитывающее количество начисленных миль за купленный билет.
Стоимость билета вы выбираете сами — заполняете переменную, в которой она будет храниться.

------

## Задание 2 — обязательное

В этой задаче мы считаем, что пользователь вводит корректные значения входных данных.

Один из сотовых операторов решил сделать своим клиентам приятный бонус: если клиент пополняет счёт более чем на 1000 рублей, то сотовый оператор дарит ему по 1 рублю за каждые полные 100 рублей пополнения.

Примеры. Начальные данные: у клиента на счету 100 рублей.
1. Клиент пополнил счёт на 300 рублей — бонусов нет, итоговая сумма на счету клиента — 400 рублей.
2. Клиент пополнил счёт на 1100 рублей — бонус равен 11 рублям, итоговая сумма на счету клиента — 1211 рублей.

Нужно создать приложение, выводящее итоговый счёт и количество бонусных рублей.
Количество денег на текущем счету клиента и сумму пополнения вы выбираете сами — создайте переменные, в которых эти данные будут храниться.

Приложение должно быть написано так, чтобы при замене значений переменных — начальной суммы счёта и суммы пополнения — итоговый счёт и бонусные рубли рассчитывались правильно.
</details>

[Моё решение к занятию «Примитивные типы данных и условные операторы». Задание 1](https://github.com/Alexnoh87/JavaIF)

[Моё решение к занятию «Примитивные типы данных и условные операторы». Задание 2](https://github.com/Alexnoh87/Java2.2)

------
<details>
<summary><b>Домашнее задание к занятию «Testability. Введение в ООП»</b></summary>

## Задание 1 — обязательное

В этой задаче мы считаем, что пользователь вводит корректные значения входных данных.

Вы уже научились создавать классы и методы. Поэтому вам необходимо модернизировать [приложение для расчёта миль](./HW_PRIMITIVES.md). Напомним, мили начисляются как 1 миля за каждые 20 рублей в стоимости билета, дробные мили не допускаются. 

Теперь сама логика расчёта будет находиться в специально выделенном классе сервиса, а в `Main` мы будем лишь создавать объект этого сервиса и вызывать его метод, передавая аргументами все необходимые данные для расчёта. Получив от вызова метода рассчитанный результат, мы выведем его на экран.

Создайте класс `BonusMilesService`: `File -> New -> Java Class`, вводите название и нажимаете `Enter`.

Определите в нём метод `calculate`, который:
* принимает на вход один параметр: цену билета, типа `int`;
* анализируя значение переданного параметра, возвращает рассчитанное количество миль.

Разместите следующий код в классе `Main`:

```java
public class Main {
    public static void main(String[] args) {
        BonusMilesService service = new BonusMilesService();
        int price = 10_000;
        int miles = service.calculate(price); // должно получиться 500
        System.out.println(miles);
    }
}
```

Убедитесь, что выводимое в консоль значение соответствует логике расчёта бонуса. Проверьте на разных примерах.

------

## Задание 2 — обязательное

В этой задаче мы считаем, что пользователь вводит корректные значения входных данных.

Вы решили написать сервис, который рассчитывает индекс массы тела (body mass index).

Формулу расчёта bmi-индекса вам предстоит найти самостоятельно.
Сервисный метод должен возвращать целое число. Чтобы дробное превратить в целое, можете использовать приведение типов: `(int) index`, где `index` имеет дробный тип.
Пример для самопроверки: для роста 1.87 метра и веса 98 кг он будет 28.

Создайте класс `BmiService` с методом `calculate`:
* который принимает все нужные данные в параметрах;
* в названии параметров указаны единицы измерения, например, в метрах ли вы принимаете рост;
* метод возвращает посчитанный bmi-индекс в виде целого числа.

Продемонстрировать в `Main` по аналогии с первой задачей:
* создание объекта;
* вызов метода `calculate`;
* печать в консоль результата, проверьте, что ваша программа считает правильно, сравнив его со своими примерами.

------

## Задание 3 — необязательное

В этой задаче мы считаем, что пользователь вводит корректные значения входных данных.

Вам поручили написать кредитный калькулятор, который считает как на сайте. Но формулы, естественно, не дали.

Вам нужно провести небольшой анализ и написать свой `CreditPaymentService`, который умеет рассчитывать ежемесячный платёж (см. аннуитетный платёж).

Параметры, их количество, типы, а также формулу вам необходимо определить самим.

Обратите внимание: на тех же данных ваш сервис должен считать так же.

Чтобы это продемонстрировать, в `Main` создайте объект и три раза вызовите его метод `calculate`. Результаты каждого вызова выводите в консоль.

Скриншоты для решения задачи. Важно: это не реальный сервис.

![image](https://user-images.githubusercontent.com/53707586/212545840-11c9918b-832a-4f19-9ade-29e5c259ecf8.png)

![image](https://user-images.githubusercontent.com/53707586/212545847-3b72640a-3c13-49dd-bacd-0020c8d4966a.png)

![image](https://user-images.githubusercontent.com/53707586/212545851-949d5826-82dc-47f7-b18a-e476819633af.png)

</details>

[Моё решение к занятию «Testability. Введение в ООП». Задание 1](https://github.com/Alexnoh87/JavaTest)

[Моё решение к занятию «Testability. Введение в ООП». Задание 2](https://github.com/Alexnoh87/Java4.2)

[Моё решение к занятию «Testability. Введение в ООП». Задание 3](https://github.com/Alexnoh87/Java4.3)

------

<details>
<summary><b>Домашнее задание к занятию «Система сборки Maven»</b></summary>

## Задание 1 (обязательное)

Нашей целью будет переделать проект с приложением про бонус с покупки на Maven и его протестировать.

**Шаг 1.** 

Создайте проект на базе Maven.

**Шаг 2.** 

Добавьте в проект JUnit Jupiter & Surefire Plugin.

**Шаг 3.** 

Создайте сервисный класс со следующим исходным кодом:

```java
public class BonusService {
  public long calculate(long amount, boolean registered) {
    int percent = registered ? 3 : 1;
    long bonus = amount * percent / 100;
    long limit = 500;
    if (bonus > limit) {
      bonus = limit;
    }
    return bonus;
  }
}
```

**Шаг 4.** 

Создайте тестовый класс со следующим исходным кодом:

```java
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Assertions;

public class BonusServiceTest {

  @Test
  void shouldCalculateForRegisteredAndUnderLimit() {
    BonusService service = new BonusService();

    // подготавливаем данные:
    long amount = 1000;
    boolean registered = true;
    long expected = 30;

    // вызываем целевой метод:
    long actual = service.calculate(amount, registered);

    // производим проверку (сравниваем ожидаемый и фактический):
    Assertions.assertEquals(expected, actual);
  }

  @Test
  void shouldCalculateForRegisteredAndOverLimit() {
    BonusService service = new BonusService();

    // подготавливаем данные:
    long amount = 1_000_000;
    boolean registered = true;
    long expected = 500;

    // вызываем целевой метод:
    long actual = service.calculate(amount, registered);

    // производим проверку (сравниваем ожидаемый и фактический):
    Assertions.assertEquals(expected, actual);
  }
}
```
**Шаг 5.** 
            
Запустите тесты через `mvn clean test`, убедитесь, что они запускаются и проходят.

**Шаг 6.** 

Проведите поверхностный тест-дизайн сервисного класса, допишите как минимум два недостающих и прямо напрашивающихся теста.

**Шаг 7.** 

Убедитесь, что тесты запускаются и проходят.

------

## Задание 2 (выполнять не обязательно)

:warning: Эта задача выполняется на основе первой задачи в том же репозитории.

Одна из частых ошибок начинающих программировать на Java — нарушение правил форматирования кода, в первую очередь в именованиях.Давайте подключим плагин, который бы автоматически проверял наличие в вашем коде неправильно названных локальных переменных и обрушал бы сборку, если находил такие.

Создадим подобный дефект. Перейдите в класс `BonusService` и переименуйте переменную в нём с `percent` на `Percent`. Убедитесь, что код компилится, тесты проходят.

Добавьте в `pom.xml` в плагины следующую настройку:
```
              <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-checkstyle-plugin</artifactId>
                <version>3.2.1</version>
                <configuration>
                    <checkstyleRules>
                        <module name="Checker">
                            <module name="TreeWalker">
                                <module name="LocalVariableName"/>
                            </module>
                        </module>
                    </checkstyleRules>
                </configuration>
                <executions>
                    <execution>
                        <id>validate</id>
                        <phase>validate</phase>
                        <goals>
                            <goal>check</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
```

Это подключит `maven-checkstyle-plugin` к вашему проекту и сконфигурирует проверку на правило `LocalVariableName`, которое проверяет правильность именований локальных переменных, а саму проверку (`check` в `executions`) будет запускать на ранней файзе `validate` ещё до тестов.

Запустите `mvn clean test`. Сборка должна упасть, так как плагин должен найти эту ошибку именования. Откройте полные логи сборки, кликнув на верхний пункт в левом нижнем окне (по умолчанию будет выделен самый нижний, как на скриншоте ниже), прокручивая окно логов сборки сверху вниз, найдите первое упоминания слова `ERROR` (с англ. «ошибка»), убедитесь, что в этой строке идёт речь про неправильное именование переменной `Percent`:

<img width="255" alt="image" src="https://user-images.githubusercontent.com/53707586/212552797-162c2265-66b0-4206-b6a3-1d3f0de55568.png">

Сделайте коммит с комментарием `Rename percent to Percent` и запушьте изменения на GitHub.Создайте баг-репорт на основе GitHub Issues. В шагах воспроизведения укажите запуск `mvn clean test`, в ожидаемом результате успешное прохождение сборки, в фактическом — падение из-за неправильного именования переменной `Percent`.

Добавьте в баг-репорт ещё один раздел для логов сборки. Синтаксис красивого его оформления будет следующим. Обратите внимание на пробелы и пустые строки, это важно, чтобы всё сработало:

<img width="341" alt="image" src="https://user-images.githubusercontent.com/53707586/212553230-ad39ce10-9eb8-4fa1-a60d-2530a5137d62.png">

После создания баг-репорта переключитесь на IDEA, исправьте дефект (переименуйте обратно на `percent`), убедитесь, что сборка проходит успешно, сделайте коммит с сообщением `Fix #1` и пуш, где `1` — это номер баг-репорта, который будет закрыт автоматически при пуше этого коммита в основную ветку.

В качестве решения второго задания пришлите ссылку на этот фикс-коммит на GitHub.
</details>

[Моё решение к занятию «Система сборки Maven». Задание 1](https://github.com/Alexnoh87/Java5.1)

[Моё решение к занятию «Система сборки Maven». Задание 2](https://github.com/Alexnoh87/Java5.1/commit/b8af000d0125cfcf3f70ac4be7e03b8656747479)

------

<details>
<summary><b>Домашнее задание к занятию «Пакеты и циклы»</b></summary>


## Задание 1 — обязательное

Один фрилансер, воспользовавшись гибкостью графика своего вида работы, решил смоделировать свой отдых по следующей схеме:
* изначально у него нет денег;
* если он решает, что следующий месяц хочет активно поработать, то его деньги увеличиваются на `income`, доход от работы, и уменьшаются на `expense`, обязательные месячные траты;
* если он решает, что следующий месяц хочет отдохнуть, то за месяц его деньги уменьшаются на `expense`, а затем остаток накоплений ещё уменьшается в три раза — траты на отдых;
* решение, отдохнуть ли в следующем месяце принимается по правилу: если на счету есть хотя бы `threshold` денег, то выбираем отдых, иначе — работу.

Вам нужно написать сервисный класс с методом, который по заданным `income`, `expenses` и `threshold` рассчитает количество месяцев отдыха, которые будут в следующий год. Всё считается в целых числах. Сервисный класс должен быть в пакете `ru.netology.services`, как и тест-класс на него.

Например, если `income` 10 тысяч руб., `expenses` 3 тысячи руб., `threshold` 20 тысяч руб., то отдохнуть удастся три месяца в году согласно следующей эмуляции планируемого поведения:
```text
Месяц 1. Денег 0. Придётся работать. Заработал +10000, потратил -3000
Месяц 2. Денег 7000. Придётся работать. Заработал +10000, потратил -3000
Месяц 3. Денег 14000. Придётся работать. Заработал +10000, потратил -3000
Месяц 4. Денег 21000. Буду отдыхать. Потратил -3000, затем ещё -12000
Месяц 5. Денег 6000. Придётся работать. Заработал +10000, потратил -3000
Месяц 6. Денег 13000. Придётся работать. Заработал +10000, потратил -3000
Месяц 7. Денег 20000. Буду отдыхать. Потратил -3000, затем ещё -11334
Месяц 8. Денег 5666. Придётся работать. Заработал +10000, потратил -3000
Месяц 9. Денег 12666. Придётся работать. Заработал +10000, потратил -3000
Месяц 10. Денег 19666. Придётся работать. Заработал +10000, потратил -3000
Месяц 11. Денег 26666. Буду отдыхать. Потратил -3000, затем ещё -15778
Месяц 12. Денег 7888. Придётся работать. Заработал +10000, потратил -3000
```

А на примере `income` 100 тысяч руб., `expenses` 60 тысяч руб., `threshold` 150 тысяч руб. ответ будет 2:
```text
Месяц 1. Денег 0. Придётся работать. Заработал +100000, потратил -60000
Месяц 2. Денег 40000. Придётся работать. Заработал +100000, потратил -60000
Месяц 3. Денег 80000. Придётся работать. Заработал +100000, потратил -60000
Месяц 4. Денег 120000. Придётся работать. Заработал +100000, потратил -60000
Месяц 5. Денег 160000. Буду отдыхать. Потратил -60000, затем ещё -66667
Месяц 6. Денег 33333. Придётся работать. Заработал +100000, потратил -60000
Месяц 7. Денег 73333. Придётся работать. Заработал +100000, потратил -60000
Месяц 8. Денег 113333. Придётся работать. Заработал +100000, потратил -60000
Месяц 9. Денег 153333. Буду отдыхать. Потратил -60000, затем ещё -62222
Месяц 10. Денег 31111. Придётся работать. Заработал +100000, потратил -60000
Месяц 11. Денег 71111. Придётся работать. Заработал +100000, потратил -60000
Месяц 12. Денег 111111. Придётся работать. Заработал +100000, потратил -60000
```

При реализации вашего сервисного метода можете опираться на пример реализации другого сервиса, считающего, сколько месяцев в году отдыхал работник, который в месяц отдыха теряет `expenses` денег, а в месяц работы получает `income` денег, а отдыхает каждый раз, когда денег хватает на следующий месяц:

```java
    public int calculate(int income, int expenses) {
        int count = 0; // счётчик месяцев отдыха
        int money = 0; // количество денег на счету
        for (int month = 0; month < 12; month++) {
            if (money >= expenses) { // можем ли отдыхать?
                count++; // увеличиваем счётчик месяцев отдыха
                money = money - expenses;
            } else {
                money = money + income;
            }
        }
        return count;
    }
```

Протестируйте ваш сервис на примерах из условия.

------

## Задание 2 — необязательное

:warning: Эта задача делается на основе первой задачи в том же репозитории.

Переделайте тесты на параметризированные на основе CSV-файлов к предыдущей задаче.
</details>

[Моё решение к занятию «Пакеты и циклы»](https://github.com/Alexnoh87/Java6.1)

------

<details>
<summary><b>Домашнее задание к занятию «Строки и массивы»</b></summary>

## Задание 1 — обязательное

Статистика — очень важный компонент любого бизнеса. У вас есть набор данных о продажах конкретного предприятия по месяцам: `[8, 15, 13, 15, 17, 20, 19, 20, 7, 14, 14, 18]`.

Программисты все заняты, и вам поручили написать небольшой сервис, который умеет по предоставленному ему массиву месячных продаж рассчитывать:
* сумму всех продаж;
* среднюю сумму продаж в месяц;
* номер месяца, в котором был пик продаж, то есть осуществлены продажи на максимальную сумму*;
* номер месяца, в котором был минимум продаж, то есть осуществлены продажи на минимальную сумму*;
* количество месяцев, в которых продажи были ниже среднего (см. п.2);
* количество месяцев, в которых продажи были выше среднего (см. п.2).

Примечание: в вашем задании нужно найти последний месяц, соответствующий условиям.

Сервис должен представлять собой один класс с шестью методами — по методу на пункт. Входные данные для расчёта сервис должен принимать в параметрах своих методов. Обратите внимание, что написанный класс должен уметь работать с любыми корректными значениями в массиве продаж, а приведённый выше набор — это лишь пример данных для ваших тестов на методы создаваемого класса.

Метод ниже считает номер месяца минимальных продаж. 
Логика его такова: заводим переменную `minMonth` для хранения номера ячейки в массиве того месяца, в котором были минимальные продажи среди всех уже просмотренных.
Изначально мы никакие ещё не просмотрели, потому запишем туда номер 0.
Будем циклом поочерёдно смотреть месяцы продаж, перебирая все номера ячеек.
Если мы смотрим на месяц, в котором продажи меньше, чем в том, который мы помним как минимальный из просмотренных ранее, то считаем теперь этот рассматриваемый месяц минимальным и присваиваем в `minMonth` значение `i`.
И так до конца массива продаж, тогда после цикла в `minMonth` у нас будет лежать номер месяца минимальных продаж.
Останется только один момент: мы нумеровали месяцы с нуля, так как в массивах ячейки нумеруются с нуля, потому, отдавая ответ, нам надо прибавить 1.

```java
    public int minSales(long[] sales) {
        int minMonth = 0; // номер месяца с минимальными продажами среди просмотренных ранее

        for (int i = 0; i < sales.length; i++) {
            if (sales[i] <= sales[minMonth]) { // значит, в рассматриваемом i-м месяце продаж меньше
                minMonth = i; // запомним его как минимальный
            }
        }

        return minMonth + 1; // месяца нумеруются с 1, а индексы массива с 0, нужно сдвинуть ответ на 1
    }
```

Вам необходимо
1. Создать Maven-проект, в котором в package `ru.netology.stats` будет класс `StatsService` с необходимыми методами, сами придумайте им говорящие названия.
1. Написать на каждый метод по одному автотесту, который проверяет правильность работы на тестовых данных.
1. Убедиться, что ваши автотесты работают и проходят.
</details>

[Моё решение к занятию «Строки и массивы»](https://github.com/Alexnoh87/Java7)

------

<details>
<summary><b>Домашнее задание к занятию «Выстраивание процесса непрерывной интеграции»</b></summary>

## Задание 1 — обязательное

Перед вами код сервисного класса:
```java
package ru.netology.statistic;

public class StatisticsService 
    public long findMax(long[] incomes) {
        long currentMax = incomes[0];
        for (long income : incomes) {
            if (currentMax < income) {
                currentMax = income;
            }
        }
        return currentMax;
    }
}
```

И код тест-класса, который его тестирует:
```java
package ru.netology.statistic;

import org.junit.jupiter.api.Test;

import org.junit.jupiter.api.Assertions;

public class StatisticsServiceTest {

  @Test
  void findMax() {
    StatisticsService service = new StatisticsService();

    long[] incomesInBillions = {12, 5, 8, 4, 5, 3, 8, 6, 11, 11, 12};
    long expected = 12;

    long actual = service.findMax(incomesInBillions);

    Assertions.assertEquals(expected, actual);
  }
}
```

Ваша задача состоит в том, чтобы:
* создать Maven-проект и поместить в него эти два класса;
* запустить `mvn clean test` и убедиться, что тесты проходят;
* создать публичный репозиторий и запушить в него проект;
* настроить CI на основе GitHub Actions, после чего не забыть сделать `git pull`;
* добавить в проект JaCoCo и настроить его в режиме обрушения сборки по недостаточному покрытию, а именно 100% покрытие по счётчику `BRANCH`;
* запустить `mvn clean verify` и убедиться, что сборка упадёт из-за недостаточного покрытия;
* проанализировать сгенерированный отчёт по покрытию, дописать недостающие тесты для полного покрытия, сам сервисный класс трогать нельзя;
* сделать коммит и пуш, убедиться, что сборка на ГитХабе проходит.
</details>

[Моё решение к занятию «Выстраивание процесса непрерывной интеграции»](https://github.com/Alexnoh87/Java8)

------

<details>
<summary><b>Домашнее задание к занятию "Объектно-ориентированное программирование: ключевые принципы"</b></summary>

## Задание 1 (обязательное)

В этой задаче, в отличие от всех последующих, настраивать CI не требуется.

Вспомните [условие задачи](https://github.com/netology-code/iqa-homeworks/tree/iqa-12/2.4#%D0%B7%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-2) из курса по ручному тестированию, где вы общались с сервером. Тогда на сервер вы посылали информацию в виде JSON — текстового формата описания объекта в JavaScript-стиле, выглядела она так:
```json
{
  "birthday": "13.06.1999",
  "name": "Иван",
  "passport": "4444 № 44444444",
  "patronymic": "Иванович",
  "phone": "+7 (999)-999-99-99",
  "surname": "Иванов"
}
```

Немного усложним и добавим в неё ещё информацию о том, согласен ли пользователь получать новости о скидках в виде sms: `"subscription": true`. Также предлагается, чтобы дата рождения была не полем-строкой, а тоже объектом: `"birthday": {"day" : 13, "month": 6, "year": 1999}`. В итоге объект в запросе будет выглядеть, например, так:

```json
{
  "birthday": {
    "day": 13,
    "month": 6,
    "year": 1999
  },
  "name": "Иван",
  "passport": "4444 № 44444444",
  "patronymic": "Иванович",
  "phone": "+7 (999)-999-99-99",
  "surname": "Иванов",
  "subscription": true
}
```

Вашей задачей будет разработать классы, описывающие объекты запроса анкеты на сервер, и продемонстрировать их работу в `Main`.

Создайте класс `Post`, описывающий объект запроса на сервер, и заполните его полями. Сперва можно без `birthday`, так как для него придётся создавать вспомогательный класс, выбрав подходящие типы:
```java
public class Post {
  public String name; // поле для имени
  // добавьте другие поля
}
```

Создадим класс `Main`, в `main` которого создадим и заполним наш объект:
```java
public class Main {
    public static void main(String[] args) {
        Post post = new Post();
        post.name = "Иван";
        // заполните другие поля
    }
}
```

Поставим точку останова на последней строчке, можно прямо на закрывающей фигурной скобке `main`, и запустим отладчик, чтобы посмотреть, что у нас будет лежать в переменной с объектом:

![image](https://user-images.githubusercontent.com/53707586/212560750-3a50d752-f62d-4554-84bf-4a81bea4bad7.png)

Если вы сделали всё правильно, то в отладчике будет виден созданный и заполненный объект типа `Post` по схеме данных — полей — указанных вами в классе `Post`.

Осталось добавить поле `birthday`. Значение в этом поле должно быть объектом, для которого также нужно будет создать свой класс. Создайте класс `FormDate` для описания схемы объекта в поле `birthday`:
```java
public class FormDate {
  // добавьте три необходимых поля
}
```

Теперь в классе `Post` добавьте поле `birthday` с типом `FormDate`. После чего добавьте заполнение этого поля в `main`:
```java
  post.birthday = new FormDate();
  post.birthday.day = 13;
  // заполните другие поля даты рождения
```

Запустите отладчик снова и убедитесь, что всё заполнено как надо и соответствует JSON-описанию объекта выше.
</details>

[Моё решение к занятию "Объектно-ориентированное программирование: ключевые принципы"](https://github.com/Alexnoh87/Java9)

------

<details>
<summary><b>Домашнее задание к занятию «Объектно-ориентированное программирование и проектирование»</b></summary>

## Задание 1 — обязательное

В рамках проекта по созданию «Умного дома» у нас появился очень важный клиент, который хочет кастомную доработку: он очень любит радио, поэтому нам нужно научиться управлять радио.

Что нужно сделать: по аналогии с кондиционером создайте класс `Radio`, в котором храните следующие поля — данные, которые будут помнить о себе объекты радио:
* номер текущей радиостанции,
* громкость звука.

Требования к работе с радиостанциями
1. Номер текущей радиостанции может принимать значения только в пределах от 0 до 9.
1. Если текущая радиостанция 9 и клиент нажал на кнопку `next` (=вызвал одноимённый метод `next`, с англ. — следующая) на пульте, то текущей должна стать нулевая. В остальных случаях при нажатии на эту же кнопку радио переключается просто на следующую станцию.
1. Если текущая радиостанция 0 и клиент нажал на кнопку `prev` (=вызвал одноимённый метод `prev`, с англ. — предыдущая) на пульте, то текущей должна стать девятая. В остальных случаях радио переключается просто на предыдущую станцию.
1. Клиент должен иметь возможность выставлять номер радиостанции через прямое указание её номера. Для этого подойдёт один обычный метод-сеттер с проверкой на допустимость номера станции.

Требования к работе с уровнем громкости звука
1. Клиент должен иметь возможность увеличивать и уменьшать уровень громкости звука в пределах от 0 до 100.
1. Если уровень громкости звука достиг максимального значения, то дальнейшее нажатие на `+` (=вызов метода увеличения громкости на один, придумайте название сами) не должно ни к чему приводить.
1. Если уровень громкости звука достиг минимального значения, то дальнейшее нажатие на `-` (=вызов метода уменьшения громкости на один, придумайте название сами) не должно ни к чему приводить.

Пример реализации метода увеличения звука на 1. Остальные методы переключения на 1 текущей станции или звука сделайте самостоятельно по аналогии:
```java
public class Radio {
  ...
  
  public void increaseVolume() {
    if (currentVolume < 100) {
      currentVolume = currentVolume + 1;
    }
  }
}
```

К созданному классу `Radio` напишите тесты, добейтесь покрытия на 100% по бранчам, обрушать сборку по покрытию при этом не нужно. То есть настройте проект в режиме генерации отчётов.
Для хорошего тестирования рекомендуем вам провести тест-дизайн перед написанием тестов, так вы с большей вероятностью найдёте дефекты в вашем коде.
</details>

[Моё решение к занятию «Объектно-ориентированное программирование и проектирование»](https://github.com/Alexnoh87/Java10.1)

------

<details>
<summary><b>Домашнее задание к занятию «Объекты с внутренним состоянием, управление состоянием при тестировании»</b></summary>

## Задание 1 — обязательное

Проект «Умный дом» развивается, и решено улучшить часть, отвечающую за радио.

Что нужно сделать: внедрить изменения в сам класс и тесты.

Как это сделать:

* создайте в Git в том же репозитории новую ветку flexible — возьмите проект к ДЗ про радио, в который уже подключены CI и нужные плагины;
* модифицируете класс `Radio` под новые требования;
* делаете тест-дизайн новой версии класса, модифицируете или добавляете новые тесты;
* пушите всё на GitHub и делаете pull request, мёржить его не нужно;
* удостоверьтесь, что все тесты в CI запускаются на pull request и проходят;
* ссылку на pull request пришлите в качестве результата ДЗ.

Требования к работе с радиостанциями

1. Можно задавать **количество радиостанций** при создании объекта, по умолчанию — 10.
1. Номер текущей радиостанции изменяется в пределах от 0 до количества радиостанций не включительно. То есть если станций 10, то номер последней — 9.
1. Если текущая радиостанция — максимальная, и клиент нажал на кнопку next на пульте, то текущей должна стать нулевая.
1. Если текущая радиостанция — 0, и клиент нажал на кнопку prev на пульте, то текущей должна стать максимальная.
1. Всё так же должен присутствовать сеттер текущей станции.

Теперь объекты радио в своём поле будут хранить и количество станций, заданное при создании объекта радио. Для этого вам понадобится создать свой конструктор для класса `Radio` с одним параметром, принимающим желаемое количество радиостанций и сохраняющим это значение у себя в поле. Ещё один конструктор потребуется без параметров, чтобы, если пользователь нашего класса не захотел указывать количество радиостанций, мы бы выставили их количество в 10 штук, как указано в требованиях, «по умолчанию — 10».

Внимание: конструктором с параметром задаётся именно количество радиостанций, а не номер максимальной, это разные вещи — если количество станций, например, 30, то последней будет номер 29, так как нумеруем мы с нуля.

Требования к работе с уровнем громкости звука:

* клиент должен иметь возможность увеличивать и уменьшать уровень громкости звука в пределах от 0 до 100;
* если уровень громкости звука достиг максимального значения, то дальнейшее нажатие на + не должно ни к чему приводить;
* если уровень громкости звука достиг минимального значения, то дальнейшее нажатие на - не должно ни к чему приводить.

Итог: ссылку на pull request пришлите в качестве результата ДЗ.

------

## Задание 2 — необязательное

Пришла пора разобраться с [Lombok](https://projectlombok.org). В вашем личном кабинете прикреплено видео, в котором демонстрируется работа с Lombok.

Что нужно сделать
1. Из ветки `flexible`, созданной в предыдущем задании, создайте ветку `lombok`, в которой перепишите ваш класс `Radio`, используя Lombok.
1. Сделайте коммит и pull request на GitHub, удостоверьтесь, что CI успешно проводит сборку, мёржить его не нужно.

### Результат
При отправке решения в личном кабинете прикрепите ссылку на ваш публичный репозиторий GitHub.
</details>

[Моё решение к занятию «Объекты с внутренним состоянием, управление состоянием при тестировании»](https://github.com/Alexnoh87/Java10.1/tree/lombok)

------

<details>
<summary><b>Домашнее задание к занятию "Композиция и зависимость объектов. Mockito при создании автотестов"</b></summary>

## Задание 1 (обязательное)

Вам необходимо реализовать менеджер афиши для фильмов. В качестве объекта фильма можно взять объект строки — название фильма — или создать свой дата-класс.

![image](https://user-images.githubusercontent.com/53707586/152697921-e71d853c-aa2e-482b-be61-39e6c2cfb0b1.png)

В этой задаче не нужно разделять менеджер и репозиторий — все фильмы должны храниться внутри массива в поле самого менеджера. Изначально, сразу после создания, менеджер не должен содержать фильмов. 

Менеджер должен уметь выполнять следующие операции:
1. Добавление нового фильма.
2. Вывод всех фильмов в порядке добавления (`findAll`).
3. Вывод максимально лимит* штук последних добавленных фильмов в обратном от добавления порядке (`findLast`).

*Сделайте так, чтобы по умолчанию выводилось последние 5 добавленных фильма, но при создании менеджера можно было указать другое число, чтобы, например, выдавать 7 или 3, а не 5. То есть у менеджера должно быть два конструктора: один без параметров, выставляющий лимит менеджера в 5, а другой с параметром, берущий значение лимита для менеджера из параметра конструктора.

Метод получения последних фильмов будет очень похож на тот, что был в лекции. Основное отличие в том, что вам в его начале надо будет вычислить правильный ожидаемый размер результирующего массива-ответа, а не просто брать длину массива, что лежит в поле. Сделать это можно, заведя целочисленную переменную, в которую вы сохраните желаемый размер создаваемого массива, вычислите с помощью условных операторов для неё значение, а затем только создадите массив, указав эту переменную как требуемый для него размер, например:

```java
...
  ??? resultLength;
  if ??? {
    resultLength = ???
  } else {
    resultLength = ???
  }
  ??? result = new ???[resultLength];
  for (???) {
    // заполняем result из массива, что лежит в поле
    // в обратном порядке
  }
...
```

Не забывайте про использование отладчика для поиска проблем вашей реализации, если тесты проходить не будут.

Напишите необходимые, с вашей точки зрения, автотесты на различные состояния менеджера. Можно делать их не в одном файле.
</details>

[Моё решение к занятию "Композиция и зависимость объектов. Mockito при создании автотестов"](https://github.com/Alexnoh87/Java12)

------

<details>
<summary><b>Домашнее задание к занятию «Наследование и расширяемость систем. Проблемы наследования»</b></summary>

## Задание 1 (обязательное)

В этом задании мы будем разрабатывать систему планировщика задач.Вам предстоит разработать и реализовать систему классов задач с использованием наследования и протестировать готовый планировщик задач.

Задачи будут трёх видов:

* `SimpleTask` — простая задача, про неё известны только `id` (число) и `title` (название);
* `Epic` — задача, состоящая из подзадач. Про неё известны `id` (число) и `subtasks` — массив из подзадач, каждая из которых является простым текстом (`String`);
* `Meeting` — задача, описывающая назначенную встречу. Про неё известны `id` — число, `topic` — тема обсуждения, `project` — название проекта, который будут обсуждать, и `start` — дата и время старта текстом.
 
Все объекты задач должны быть не изменяемы — исходные данные принимать в конструкторе при создании и не иметь сеттеров (только геттеры).

Мы хотим задачи хранить в менеджере. Назовём его класс `Todos` — список дел.Было бы удобно хранить в нём задачи не по отдельности (т. е. один массив из `SimpleTask`, другой массив из `Epic`, третий массив из `Meeting`), а в одном общем массиве.Это позволит сильно сократить и упростить код менеджера, а также мы сможем создавать новые виды задач без изменений кода `Todos`.Чтобы хранить все задачи в одном массиве, нам нужен такой тип ячейки, который позволит в неё положить любую из наших задач.С этим поможет полиморфизм, для которого мы создадим класс `Task`, в который вынесем общее, что есть во всех задачах, а другие задачи от него отнаследуем:

```java
import java.util.Objects;

public class Task {
    protected int id;

    public Task(int id) {
        this.id = id;
    }

    public int getId() {
        return id;
    }

    // Ниже находятся вспомогательные методы для корректной работы equals
    // Переопределять их в наследниках не нужно

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Task task = (Task) o;
        return id == task.id;
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
}
```

А в классах задач будет `public class SimpleTask extends Task {...`, `public class Epic extends Task {...` и `public class Meeting extends Task {...`.

Реализация наследника на примере `SimpleTask`:

```java
public class SimpleTask extends Task {
    protected String title;

    public SimpleTask(int id, String title) {
        super(id); // вызов родительского конструктора
        this.title = title; // заполнение своих полей
    }

    public String getTitle() {
        return title;
    }
}
```

Реализуйте оставшиеся два класса — `Epic` и `Meeting`.

Это позволит нам в менеджере создать единый массив хранения задач, в который мы сможем положить любую из задач:

```java
public class Todos {

    private Task[] tasks = new Task[0]; // <- тут будут все задачи

    /**
     * Вспомогательный метод для имитации добавления элемента в массив
     * @param current Массив, в который мы хотим добавить элемент
     * @param task Элемент, который мы хотим добавить
     * @return Возвращает новый массив, который выглядит как тот, что мы передали,
     * но с добавлением нового элемента в конец
     */
    private Task[] addToArray(Task[] current, Task task) {
        Task[] tmp = new Task[current.length + 1];
        for (int i = 0; i < current.length; i++) {
            tmp[i] = current[i];
        }
        tmp[tmp.length - 1] = task;
        return tmp;
    }

    /**
     * Метод добавления задачи в список дел
     * @param task Добавляемая задача
     */
    public void add(Task task) { // <- вот здесь в параметре может лежать объект и вида SimpleTask, и вида Epic, и вида Meeting
        tasks = addToArray(tasks, task);
    }
    
    public Task[] findAll() {
        return tasks;
    }
}

```

Проверим это следующим тестом. Поместите его в `TodosTest`-класс:

```java    
    @Test
    public void shouldAddThreeTasksOfDifferentType() {
        SimpleTask simpleTask = new SimpleTask(5, "Позвонить родителям");

        String[] subtasks = { "Молоко", "Яйца", "Хлеб" };
        Epic epic = new Epic(55, subtasks);

        Meeting meeting = new Meeting(
                555,
                "Выкатка 3й версии приложения",
                "Приложение НетоБанка",
                "Во вторник после обеда"
        );

        Todos todos = new Todos();

        todos.add(simpleTask);
        todos.add(epic);
        todos.add(meeting);

        Task[] expected = { simpleTask, epic, meeting };
        Task[] actual = todos.findAll();
        Assertions.assertArrayEquals(expected, actual);
    }
```

Теперь давайте добавим в менеджер возможность искать задачи по посковому запросу (`query`).Подходит ли задача запросу, будет решать сама задача, для чего мы в `Task` заведём метод `matches`.

```java    
    /**
     * Метод, проверяющий подходит ли эта задача поисковому запросу.
     * Эта логика должна быть определена в наследниках, у каждого она будет своя
     * @param query Поисковый запрос
     * @return Ответ на вопрос, подходит ли эта задача под поисковый запрос
     */
    public boolean matches(String query) {
        return false;
    }
```

В каждом же наследнике мы переопределим этот метод так, чтобы:

* `SimpleTask` подходил, если запрос `query` встречается в `title`;

* `Epic` подходил, если запрос `query` встречается хотя бы в одной из подзадач;
* `Meeting` подходил, если запрос `query` встречается в `topic` или `project`.

Рассмотрим на примере переопределения этого метода для класса `Meeting`.Мы воспользуемся методом `contains`, который есть у каждого объекта типа `String`: `s1.contains(s2)` отвечает на вопрос, содержится ли текст из `s2` в тексте из `s1`.В итоге мы может переопределить метод так:

```java    
    @Override
    public boolean matches(String query) {
        if (topic.contains(query)) {
            return true;
        }
        if (project.contains(query)) {
            return true;
        }
        return false;
    }
```

Переопределите метод `matches` для двух оставшихся классов.Для `SimpleTask` это можно сделать одним if, для `Epic` — циклом перебирая подзадачи и также проверяя каждую через `if`.Напишите тесты на метод `matches` для всех трёх классов, поместите их в `TasksTest`-классе.

Теперь мы можем добавить метод поиска в сам класс `Todos`:

```java    
    /**
     * Метод поиска задач, которые подходят под поисковый запрос
     * @param query Поисковый запрос
     * @return Массив из подошедших задач
     */
    public Task[] search(String query) {
        Task[] result = new Task[0]; // массив для ответа
        for (Task task : tasks) { // перебираем все задачи
            if (task.matches(query)) { // если задача подходит под запрос
                result = addToArray(result, task); // добавляем её в массив ответа
            }
        }
        return result;
    }
```

Напишите тесты на метод поиска в классе `TodosTest`.
</details>

[Моё решение к занятию «Наследование и расширяемость систем. Проблемы наследования»](https://github.com/Alexnoh87/Java13)

------

<details>
<summary><b>Домашнее задание к занятию «Исключительные ситуации и их обработка. Тестирование исключений»</b></summary>

## Задание 1 (обязательное)

Представим себе репозиторий, хранящий товары.

Товары будут описываться классом `Product`:

```java
public class Product {
    protected int id;
    protected String title;
    protected int price;

    public Product(int id, String title, int price) {
        this.id = id;
        this.title = title;
        this.price = price;
    }
    
    // Вспомогательные методы для корректной работы equals
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Product product = (Product) o;
        return id == product.id && price == product.price && title.equals(product.title);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id, title, price);
    }
    
    // геттеры + сеттеры
    // на id только геттер — пусть будет неизменяемым для товара
}
```

И репозиторий:

```java
public class ShopRepository {
    private Product[] products = new Product[0];

    /**
     * Вспомогательный метод для имитации добавления элемента в массив
     * @param current — массив, в который мы хотим добавить элемент
     * @param product — элемент, который мы хотим добавить
     * @return — возвращает новый массив, который выглядит, как тот, что мы передали,
     * но с добавлением нового элемента в конец
     */
    private Product[] addToArray(Product[] current, Product product) {
        Product[] tmp = new Product[current.length + 1];
        for (int i = 0; i < current.length; i++) {
            tmp[i] = current[i];
        }
        tmp[tmp.length - 1] = product;
        return tmp;
    }

    /**
     * Метод добавления товара в репозиторий
     * @param product — добавляемый товар
     */
    public void add(Product product) {
        products = addToArray(products, product);
    }

    public Product[] findAll() {
        return products;
    }

    // Этот способ мы рассматривали в теории в теме про композицию
    public void remove(int id) {
        Product[] tmp = new Product[products.length - 1];
        int copyToIndex = 0;
        for (Product product : products) {
            if (product.getId() != id) {
                tmp[copyToIndex] = product;
                copyToIndex++;
            }
        }
        products = tmp;
    }
}
```

Вы решили сделать так, чтобы при попытке удаления несуществующего объекта из репозитория генерировалось ваше исключение, а не `ArrayIndexOfBoundsException`.

Обратите внимание: это правильный подход, поскольку так вы сообщаете через генерацию исключения, что это исключение, вписывающееся в вашу логику, а не ошибка программиста.

**Что нужно сделать**

1. Создайте класс исключения `NotFoundException`, отнаследовавшись от `RuntimeException`, и реализуйте как минимум конструктор с параметром-сообщением. Он будет просто вызывать суперконструктор предка (см. ниже).
1. В методе удаления `removeById` сначала проверяйте, есть ли элемент. Для этого прямо из метода `removeById` вызывайте метод `findById`: если результат `null`, тогда выкидывайте исключение `NotFoundException`.
1. Напишите два автотеста на репозиторий: первый должен проверять успешность удаления существующего элемента, второй — генерации `NotFoundException` при попытке удаления несуществующего элемента.

Конструктор вашего исключения должен выглядеть так:

```java
	public NotFoundException(String s) {
		super(s);
	}
```

Для реализации этой логики вам понадобится добавить метод `findById`, предназначенный для поиска товара в репозитории по его ID.
Так он должен принимать параметр `ID` искомого товара, пробегаться по всем товарам репозитория и сверять их `ID` с искомым, в случае совпадения делать `return` этого товара.

Если же, пробежав все товары репозитория, ни один подходящий найден не был, то есть цикл закончился без вызова `return` внутри него, то следует сделать `return null`.

Общая схема этого метода будет такой:

```java
public Product findById(???) {
  for (???) {
    if (???) {
      return product;
    }
  }
  return null;
}
```

Убедитесь, что ваши автотесты проходят. Напоминаем, что проект должен быть на базе Maven, с подключёнными зависимостями и необходимыми плагинами.

Мы рекомендуем вам указывать в сообщении исключения: при удалении по какому конкретно ID было сгенерировано ваше исключение.

Простейший способ, как это можно сделать: ```"Element with id: " + id + " not found"```.

------

## Задание 2* (необязательное)

В том же проекте и в той же ветке добавьте новую функциональность. 

В методе добавления нового товара в репозиторий должна осуществляться проверка на то, что в нём уже нет товара, у которого бы совпадал `ID` с `ID` добавляемого товара. Если же такой есть, то должно выкидываться ваше исключение — `AlreadyExistsException`. 

Напишите два автотеста на репозиторий: первый должен проверять успешность добавления элемента, второй — генерации `AlreadyExistsException` при попытке добавить элемент с повторяющимся `ID`.
</details>

[Моё решение к занятию «Исключительные ситуации и их обработка. Тестирование исключений»](https://github.com/Alexnoh87/Java14)

------

<details>
<summary><b>Домашнее задание к занятию «Интерфейсы для организации малой связности. Обобщённое программирование (Generics)»</b></summary>

## Задание 1 (обязательное)

Перед вами класс, описывающий билет на самолёт. Точнее, предложение авиакомпании по перелёту:

```java
import java.util.Objects;

public class Ticket {
    private String from; // аэропорт откуда
    private String to; // аэропорт куда
    private int price; // цена
    private int timeFrom; // время вылета (по москве)
    private int timeTo; // время прилёта (по москве)

    public Ticket(String from, String to, int price, int timeFrom, int timeTo) {
        this.from = from;
        this.to = to;
        this.price = price;
        this.timeFrom = timeFrom;
        this.timeTo = timeTo;
    }

    public String getFrom() {
        return from;
    }

    public String getTo() {
        return to;
    }

    public int getPrice() {
        return price;
    }

    public int getTimeFrom() {
        return timeFrom;
    }

    public int getTimeTo() {
        return timeTo;
    }


    // Вспомогательные методы для корректной работы equals
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Ticket ticket = (Ticket) o;
        return price == ticket.price && timeFrom == ticket.timeFrom && timeTo == ticket.timeTo && from.equals(ticket.from) && to.equals(ticket.to);
    }

    @Override
    public int hashCode() {
        return Objects.hash(from, to, price, timeFrom, timeTo);
    }
}
```

Ниже менеджер, который умеет хранить и искать эти билеты:

```java
public class AviaSouls {
    private Ticket[] tickets = new Ticket[0];

    /**
     * Вспомогательный метод для имитации добавления элемента в массив
     * @param current Массив, в который мы хотим добавить элемент
     * @param ticket Элемент, который мы хотим добавить
     * @return Возвращает новый массив, который выглядит как тот что мы передали,
     * но с добавлением нового элемента в конец
     */
    private Ticket[] addToArray(Ticket[] current, Ticket ticket) {
        Ticket[] tmp = new Ticket[current.length + 1];
        for (int i = 0; i < current.length; i++) {
            tmp[i] = current[i];
        }
        tmp[tmp.length - 1] = ticket;
        return tmp;
    }

    /**
     * Метод добавления билета в менеджер
     * @param ticket Добавляемый билет
     */
    public void add(Ticket ticket) {
        tickets = addToArray(tickets, ticket);
    }

    public Ticket[] findAll() {
        return tickets;
    }

    /**
     * Метод поиска билетов по маршруту
     * @param from Откуда вылетаем
     * @param to Куда прилетаем
     * @return Массив из подходящих билетов
     */
    public Ticket[] search(String from, String to) {
        Ticket[] result = new Ticket[0]; // массив для ответа
        for (Ticket ticket : tickets) { // перебираем все билеты
            if (ticket.getFrom().equals(from)) { // совпадает аэропорт вылета
                if (ticket.getTo().equals(to)) { // совпадает аэропорт прилёта
                    result = addToArray(result, ticket); // добавляем его в массив ответа
                }
            }
        }
        return result;
    }
}

```

Но оказалось, что пользоваться таким менеджером не очень удобно: он не сортирует ни по цене, ни по времени перелёта.Новую логику предстоит добавить вам.

Сначала сделайте так, что билеты по умолчанию сравниваются по цене.Для этого добавьте `implements Comparable<Ticket> {` в класс `Ticket` и реализуйте метод `compareTo` из интерфейса так, чтобы один билет считался меньше другого, если цена первого меньше цены второго.Протестируйте работу метода `compareTo`.

Добавьте сортировку массива ответа в методе `search`, чтобы билеты упорядочивались в порядке возрастания цены. Протестируйте метод поиска.

Создайте класс `TicketTimeComparator`, который имплементировал бы компаратор для билетов:

```java
import java.util.Comparator;

public class TicketTimeComparator implements Comparator<Ticket> {
    
    @Override
    public int compare(Ticket t1, Ticket t2) {
        // ваш код
    }
}
```

Компаратор должен сравнивать два билета так, что первый считался бы меньше, чем второй, если его время полёта меньше чем время полёта второго.Протестируйте этот компаратор.

Добавьте в менеджер метод `searchAndSortBy(String from, String to, Comparator<Ticket> comparator)`, который также бы искал билеты, но сортировал их уже по логике переданного параметром компаратора.
Протестируйте этот метод, используя созданный выше компаратор.

Все тесты должны быть в тест-классе `AviaSoulsTest`.
</details>

[Моё решение к занятию «Интерфейсы для организации малой связности. Обобщённое программирование (Generics)»](https://github.com/Alexnoh87/Java15)

------

<details>
<summary><b>Домашнее задание к занятию "Collections Framework. CRUD и тестирование систем, управляющих набором объектов"</b></summary>

## Задание 1 (обязательное)

Ваша задача — разработать класс, управляющий турниром игроков. Каждый игрок описывается дата-классом `Player` с полями `id`, `name`, `strength` (сила).

Сам же турнир описывается классом `Game` с методами:
* `register (Player player)` — метод регистрации игрока, если игрок не зарегистрирован, то он не сможет играть в турнире. Вам нужно хранить всех зарегистрированных игроков в поле класса `Game` в виде списка.
* `round (String playerName1, String playerName2)` — метод соревнования между двумя игроками. Если хотя бы один из игроков не зарегистрирован, должно выкинуться исключение `NotRegisteredException` — сами создайте его класс. Обратите внимание, что игроки передаются методу через имя — полную информацию об игроке нужно будет найти в коллекции зарегистрированных игроков (см. аналог в виде `findById` из прошлых домашних заданий). Выигрывает тот игрок, у которого больше `strength` (сила), если сила одинаковая, то будет ничья. Метод должен возвращать одно число — `0` в случае ничьи, `1` в случае победы первого игрока и `2` в случае победы второго игрока.

Напишите на класс `Game` тесты, покрыв по бранчам на 100%.

Итого: отправьте на проверку ссылку на репозиторий GitHub с вашим проектом. 

------

## Задание 2 (НЕобязательное)

Отведите ветку `fast` в репозитории прошлой задачи и выполняйте эту задачу в ней.
Доработайте прошлую задачу, заменив коллекцию списка игроков на мапу (`HashMap`) для быстрого поиска информации об игроке по его имени.
Создайте Pull Request этой ветки к основной, но не применяйте его.
Убедитесь, что все тесты проходят, CI работает на вашей ветке.
</details>

[Моё решение к занятию "Collections Framework. CRUD и тестирование систем, управляющих набором объектов"](https://github.com/Alexnoh87/Java16)

------
